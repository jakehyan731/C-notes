\section{\IFRU{Операторы}{Operators}}

\subsection{==}

Очень неприятные ошибки возникают если в условии \IT{if(a==3)} опечататься и написать \IT{if(a=3)}.
Ведь выражение \IT{a=3} ``возвращает'' 3, а 3 это не 0, поэтому условие if() всегда будет 
срабатывать.

Раньше, для защиты от подобных ошибок, была мода писать наоборот: \IT{if(3==a)}, таким образом,
если опечататься, выйдет \IT{if(3=a)}, компилятор тут же выдаст ошибку.

Тем не менее, в наше время, компиляторы обычно предупреждают если написать \IT{if(a==3)}, 
так что, наверное, менять местами элементы выражения уже не обязательно.

\subsection{Short-circuit evaluation и артефакт приоритетов операций}

Разберем что такое short-circuit\footnote{дословный перевод на русский: ``короткое замыкание''} evaluation.

Это когда в выражении \IT{if(a \&\& b \&\& c)}, часть \IT{b} будет вычисляться только если \IT{a} -- истинна,
а \IT{c} будет вычисляться
только если \IT{a} и \IT{b} -- истинны. И вычисляться они будут именно в таком порядке, как указано.

Иногда можно встретить подобное: \IT{if (p!=NULL \&\& p->field==123)} -- и это совершенно правильно.
Поле \IT{field} в структуре,
на которую указывает \IT{p}, будет вычисляться только если указатель \IT{p} не равен NULL.

То же касается и операции ``или'', если в выражении \IT{if (a || b || c)} подвыражение a будет ``истинно'',
остальные вычисляться не будут. Это может быть удобно для вызова нескольких ф-ций: 
\IT{if (get\_flagsA() || get\_flagsB() || get\_flagsC())} --- если первая или вторая ф-ция вернет true, 
остальные даже не будут вызываться.

Эта особенность есть не только в Си/Си++
\footnote{Здесь список ЯП где присутствует short-circuit evaluation\url{https://en.wikipedia.org/wiki/Short-circuit_evaluation}}.

Когда-то давно\cite{dmr:1995}, в языках B и BCPL (предтечи Си) не было операторов \IT{\&\&} и \IT{||}, 
но чтобы реализовать в них
short-circuit evaluation, приоритет операций \IT{\&} и \IT{|} сделали больше, чем, например, у \IT{\^} или \IT{+}
\footnote{\IFRU{Приоритет операций в Си++}{C++ Operator Precedence}: \url{http://en.cppreference.com/w/cpp/language/operator_precedence}}.

Это позволяло писать что-то вроде \IT{if (a==1 \& b==c)} используя \IT{\&} вместо \IT{\&\&}. Вот откуда взялся
этот артефакт в приоритетах.
Так что, нередкая ошибка это забывать о высоком приоритете этих операций и писать, например,
\IT{if (a\&1==0)}, в то время как это нужно брать в скобки: \IT{if ((a\&1)==0)}.

