\chapter{\IFRU{Стандартные библиотеки Си/Си++}{C/C++ standard library}}

\section{assert}

Как известно, этот макрос часто используется для валидации
\footnote{используется также такой термин как ``инвариант'' и ``sanitization'' в англ.яз.} заданных значений. 
Например, если ваша ф-ция
работает с датой, вы, вероятно, захотите написать в её начале что-то вроде \IT{assert (month>=1 \&\& month<=12)}.

Вот то о чем нужно помнить: стандартный макрос assert() доступен только в отладочных (debug) сборках. В release
все выражения как бы исчезают. Поэтому писать, например, \IT{assert(f=malloc(...))} неверно. Впрочем,
вы возможно захотите использовать что-то вроде \IT{assert(object->get\_something()==123)}.

В макросах assert можно также указывать небольшие сообщения об ошибках: 
вы увидите их если assert() ``не сойдется''. 
Например, в исходниках LLVM\footnote{\url{http://llvm.org/}} можно встретить такое:

\begin{lstlisting}
assert(Index < Length && "Invalid index!");
...
assert(i + Count <= M && "Invalid source range");
...
assert(j + Count <= N && "Invalid dest range");
\end{lstlisting}

Текстовая строка имеет тип \IT{const char*}, и она никогда не NULL. 
Таким образом, можно дописать к любому выражению \IT{... \&\& true} не меняя его смысл.

\section{Разница между stdout и stderr}

\IT{stdout} это то что выводится на консоль при помощи вызова \IT{printf()}.
\IT{stdout} это буферизированный вывод,
так что, пользователь, обычно того не зная, видит вывод порциями. Бывает так что программа выдает
что-то используя \IT{printf()} либо \IT{cout} и тут же падает.
Если это попадает в буфер, но буфер не успевает
``сброситься'' (flush) в консоль, то пользователь ничего не увидит. Это бывает неудобно.
Таким образом, для вывода более важной информации, в том числе отладочной, удобнее использовать \IT{stderr}.

\IT{stderr} это не буферизированный вывод, и всё что попадает в этот поток при помощи 
\TT{fprintf(stderr,...)} либо \IT{cerr}, появляется в консоли тут же.

Не следует также забывать, что из-за отсутствия буфера, вывод в \IT{stderr} медленнее.

Чтобы направлять \IT{stderr} в другой файл при запуске процесса, можно указывать:

\begin{lstlisting}
process 2> debug.txt
\end{lstlisting}

... это направит вывод \IT{stderr} в заданный файл (потому что номер этого потока -- 2).

\section{UNIX time}

В UNIX-среде очень популярно представление даты и времени в формате UNIX time.
Это просто 32-битное число, показывающее
количество прошедших секунд с 1-го января 1970-го года.

В качестве положительных сторон: 1) очень легко хранить это 32-битное число; 2) очень легко вычислять разницу дат;
3) невозможно закодировать неверные даты и время, такие как 32-е января, 29-е февраля невысокосных годов, 
25 часов 62 минуты.

В качестве отрицательных сторон: 1) нельзя закодировать дату до 1970-го года.

В наше время, если использовать UNIX time, тем не менее, следует помнить что ``срок его действия'' истечет
в 2038-м году, именно тогда 32-битное число переполнится, то есть, пройдет $2^{32}$ секунд с 1970-го года.
Так что, для этого следует использовать 64-битное значение, т.е., time64.

% ? NtQuerySystemTime http://msdn.microsoft.com/en-us/library/windows/desktop/ms724512(v=vs.85).aspx

\section{scanf(), fscanf(), sscanf()}

\subsection{Засада \#1}

Если использовать \%d в строке формата, scanf() подразумевает что это 32-битный int. 

Ошибкой является подобное:

\begin{lstlisting}
char a[10];

scanf ("%d %d %d %d", &a[0], &a[1], &a[2], &[3]);
\end{lstlisting}

Символы (или байты) лежат ``в притык'' друг к другу. Когда scanf() будет обрабатывать первое значение, он будет считать
его за 32-битный int, и ``затрет'' остальные три, рядом лежащие. И так далее.

\label{memcpy}
\section{memcpy()}

Поначалу трудно запомнить порядок аргументов в ф-циях memcpy(), strcpy(). Чтобы было легче, можно представлять
знак ``равно'' между аргументами.

\label{bzero}
\section{bzero() и memset()}

bzero() это ф-ция просто обнуляющая блок памяти.
Для этого обычно используют memset(). Но у memset() есть неприятная особенность, легко перепутать второй
и третий аргументы местами, и компилятор промолчит, потому что байт для заполнения всего блока задается как int.

К тому же, имя ф-ции bzero легче читается.

С другой стороны, её нет в стандарте POSIX.

\label{printf}
\section{printf()}

\subsection{Свои собственные модификаторы в printf()}

Часто можно испытать раздражение, когда было бы логично передать в printf(), скажем, структуру описывающее комплексное
число, или цвет закодированный в структуре из трех чисел типа int.

В printk() (printf-подобная ф-ция в ядре Linux) имеются дополнительные модификаторы
\footnote{\url{http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/printk-formats.txt}}, 
такие как \TT{\%pM} (Mac-адрес), \TT{\%pI4} (IPv4-адрес), \TT{\%pUb} (UUID/GUID).

В ОС Plan9, и в исходниках компилятора Go, можно найти ф-цию fmtinstall(), объявляющую новый модификатор printf-строки,
например:

\begin{lstlisting}[caption=go\textbackslash{}src\textbackslash{}cmd\textbackslash{}5c\textbackslash{}list.c]
void
listinit(void)
{

	fmtinstall('A', Aconv);
	fmtinstall('P', Pconv);
	fmtinstall('S', Sconv);
	fmtinstall('N', Nconv);
	fmtinstall('B', Bconv);
	fmtinstall('D', Dconv);
	fmtinstall('R', Rconv);
}

...

int
Pconv(Fmt *fp)
{
	char str[STRINGSZ], sc[20];
	Prog *p;
	int a, s;

	p = va_arg(fp->args, Prog*);
	a = p->as;
	s = p->scond;
	strcpy(sc, extra[s & C_SCOND]);
	if(s & C_SBIT)
		strcat(sc, ".S");
	if(s & C_PBIT)
		strcat(sc, ".P");
	if(s & C_WBIT)
		strcat(sc, ".W");
	if(s & C_UBIT)		/* ambiguous with FBIT */
		strcat(sc, ".U");
	if(a == AMOVM) {
		if(p->from.type == D_CONST)
			sprint(str, "	%A%s	%R,%D", a, sc, &p->from, &p->to);
		else
		if(p->to.type == D_CONST)
			sprint(str, "	%A%s	%D,%R", a, sc, &p->from, &p->to);
		else
			sprint(str, "	%A%s	%D,%D", a, sc, &p->from, &p->to);
	} else
	if(a == ADATA)
		sprint(str, "	%A	%D/%d,%D", a, &p->from, p->reg, &p->to);
	else
	if(p->as == ATEXT)
		sprint(str, "	%A	%D,%d,%D", a, &p->from, p->reg, &p->to);
	else
	if(p->reg == NREG)
		sprint(str, "	%A%s	%D,%D", a, sc, &p->from, &p->to);
	else
	if(p->from.type != D_FREG)
		sprint(str, "	%A%s	%D,R%d,%D", a, sc, &p->from, p->reg, &p->to);
	else
		sprint(str, "	%A%s	%D,F%d,%D", a, sc, &p->from, p->reg, &p->to);
	return fmtstrcpy(fp, str);
}
\end{lstlisting}
(\url{http://plan9.bell-labs.com/sources/plan9/sys/src/cmd/5c/list.c})

Ф-ция Pconv() будет вызвана если в строке формата будет встречен \%P. Затем она копирует созданную строку
при помощи fmtstrcpy(). Кстати, эта ф-ция и сама использует другие объявленные модификаторы, такие как \%A, \%D, итд.

В Glibc есть нестандартное расширение
\footnote{\url{http://www.gnu.org/software/libc/manual/html_node/Customizing-Printf.html}}, 
позволяющее объявлять свои модификаторы, но это \IT{deprecated}.

Попробуем определить свои собственные модификаторы для Mac-адреса и для вывода байта в бинарном виде:

\lstinputlisting{register_printf_function.c}
\footnote{Основа для примера взята отсюда: \url{http://codingrelic.geekhold.com/2008/12/printf-acular.html}}

Это компилируется с предупреждениями:

\begin{lstlisting}
1.c: In function 'main':
1.c:48:2: warning: 'register_printf_function' is deprecated (declared at /usr/include/printf.h:106) [-Wdeprecated-declarations]
1.c:49:2: warning: 'register_printf_function' is deprecated (declared at /usr/include/printf.h:106) [-Wdeprecated-declarations]
1.c:51:2: warning: unknown conversion type character 'M' in format [-Wformat]
1.c:52:2: warning: unknown conversion type character 'B' in format [-Wformat]
\end{lstlisting}

GCC умеет следить за соответствиями модификаторов в printf-строке и аргументами в вызове printf(), но здесь
ему встречаются незнакомые модификаторы, о чем он предупреждает.

Тем не менее, наша программа работает:

\begin{lstlisting}
$ ./a.out
00:11:22:33:44:55
10101011
\end{lstlisting}

