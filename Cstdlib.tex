\chapter{\IFRU{Стандартные библиотеки Си/Си++}{C/C++ standard library}}

\section{assert}

Как известно, этот макрос часто используется для валидации
\footnote{используется также такой термин как ``инвариант'' и ``sanitization'' в англ.яз.} заданных значений. 
Например, если ваша ф-ция
работает с датой, вы, вероятно, захотите написать в её начале что-то вроде \IT{assert (month>=1 \&\& month<=12)}.

Вот то о чем нужно помнить: стандартный макрос assert() доступен только в отладочных (debug) сборках. В release
все выражения как бы исчезают. Поэтому писать, например, \IT{assert(f=malloc(...))} неверно. Впрочем,
вы возможно захотите использовать что-то вроде \IT{assert(object->get\_something()==123)}.

В макросах assert можно также указывать небольшие сообщения об ошибках: 
вы увидите их если assert() ``не сойдется''. 
Например, в исходниках LLVM\footnote{\url{http://llvm.org/}} можно встретить такое:

\begin{lstlisting}
assert(Index < Length && "Invalid index!");
...
assert(i + Count <= M && "Invalid source range");
...
assert(j + Count <= N && "Invalid dest range");
\end{lstlisting}

Текстовая строка имеет тип \IT{const char*}, и она никогда не NULL. 
Таким образом, можно дописать к любому выражению \IT{... \&\& true} не меняя его смысл.

\section{Разница между stdout и stderr}

\IT{stdout} это то что выводится на консоль при помощи вызова \IT{printf()}.
\IT{stdout} это буферизированный вывод,
так что, пользователь, обычно того не зная, видит вывод порциями. Бывает так что программа выдает
что-то используя \IT{printf()} либо \IT{cout} и тут же падает.
Если это попадает в буфер, но буфер не успевает
``сброситься'' (flush) в консоль, то пользователь ничего не увидит. Это бывает неудобно.
Таким образом, для вывода более важной информации, в том числе отладочной, удобнее использовать \IT{stderr}.

\IT{stderr} это не буферизированный вывод, и всё что попадает в этот поток при помощи 
\TT{fprintf(stderr,...)} либо \IT{cerr}, появляется в консоли тут же.

Не следует также забывать, что из-за отсутствия буфера, вывод в \IT{stderr} медленнее.

Чтобы направлять \IT{stderr} в другой файл при запуске процесса, можно указывать:

\begin{lstlisting}
process 2> debug.txt
\end{lstlisting}

... это направит вывод \IT{stderr} в заданный файл (потому что номер этого потока -- 2).

\section{UNIX time}

В UNIX-среде очень популярно представление даты и времени в формате UNIX time.
Это просто 32-битное число, показывающее
количество прошедших секунд с 1-го января 1970-го года.

В качестве положительных сторон: 1) очень легко хранить это 32-битное число; 2) очень легко вычислять разницу дат;
3) невозможно закодировать неверные даты и время, такие как 32-е января, 29-е февраля невысокосных годов, 
25 часов 62 минуты.

В качестве отрицательных сторон: 1) нельзя закодировать дату до 1970-го года.

В наше время, если использовать UNIX time, тем не менее, следует помнить что ``срок его действия'' истечет
в 2038-м году, именно тогда 32-битное число переполнится, то есть, пройдет $2^{32}$ секунд с 1970-го года.
Так что, для этого следует использовать 64-битное значение, т.е., time64.

% NtQuerySystemTime http://msdn.microsoft.com/en-us/library/windows/desktop/ms724512(v=vs.85).aspx

