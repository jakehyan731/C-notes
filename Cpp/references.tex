\subsection{references}

\index{C++!references}
\IFRU{Это то же что и указатели (\ref{pointers}), но ``обезопасенные'' (safe), 
потому что работая с ними, труднее сделать ошибку}
{It is the same thing as pointers (\ref{pointers}), but ``safe'', 
because it is harder to make a mistake while working with them}
\cite[8.3.2]{CPP11}.

\IFRU{Например, reference всегда должен указывать объект того же типа и не может быть NULL}
{For example, reference should be always be pointing to the object of corresponding type and can't be NULL}
\cite[8.6]{ParashiftCPPFAQ}.
\IFRU{Более того, reference нельзя менять, нельзя его заставить указывать на другой объект (reseat)}
{Even more, reference cannot be changed, it's not possible to point to to another object (reseat)}
\cite[8.5]{ParashiftCPPFAQ}.

\IFRU{В}{In} \cite[1.7.1]{REBook} \IFRU{продемонстрировано, что на уровне x86-кода, это одно и то же}
{it was demonstrated that on x86-level of code it is the same thing}.

\IFRU{Как и указатели, \IT{reference} также можно возвращать из ф-ций, например}
{Just like pointers, \IT{references} can be returned by functions, e.g.}:

\begin{lstlisting}
#include <iostream>
 
int& use_count()
{
	static int uc=1000; // starting value
	return uc;
};
 
void main()
{
	std::cout << ++use_count() << std::endl;
	std::cout << ++use_count() << std::endl;
	std::cout << ++use_count() << std::endl;
	std::cout << ++use_count() << std::endl;
};
\end{lstlisting}

\IFRU{Это выведет предсказуемое}{This will print predictable}:

\begin{lstlisting}
1001
1002
1003
1004
\end{lstlisting}

\IFRU{Если посмотреть что сгенерировалось на языке ассемблера, то можно увидеть что}
{If to see what was generated in assembly language, it can be seen that} \TT{use\_count()} 
\IFRU{просто возвращает указатель на}{just returns a pointer to} \TT{uc}, 
\IFRU{а в}{and in the} \TT{main()} \IFRU{происходит инкремент значения по этому указателю}
{an increment of a value on this pointer is occuring}.

