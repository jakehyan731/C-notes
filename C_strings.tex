\section{Строки в Си}

В Си нет встроенных возможностей для удобной работы со строками, такими, какие имеются в ЯП более
высокого уровня.

Часто жалуются на неудобную
конкатенацию строк (то есть, склеивание) в Си при помощи функции strcat(). Также, многих раздражает sprintf(),
под которых нельзя толком зараннее предсказать, сколько нужно выделять памяти. Копирование строк при помощи
strcpy() также неудобно --- нужно думать, сколько же выделить байт под буфер. Помимо всего прочего, неудобная
работа со строками в Си, это источник огромного количества уязвимостей в ПО, связанных с переполнениями буфера\cite[1.14.2]{REBook}.

Прежде всего, нужно задать себе вопрос, какие операции со строками нам нужны.
Конкатенация (склеивание) нужна чтобы 1) выдавать в лог сообщения; 2) конструировать строки и записывать их куда-то.

Для 1) можно использовать потоки (streams) --- не конструируя строку, выдавать её по порциям, например:

\begin{lstlisting}
printf ("Date: ");
dump_date(stdout, date);
printf (" a=");
dump_a(stdout, a);
printf ("\n");
\end{lstlisting}

Подобное заменяется в Си++ выводом в ostream:

\begin{lstlisting}
cout << "Date: " << Date_ToString(date) << " a=" << a_ToString(a) << "\n";
\end{lstlisting}

Так быстрее и меньше требуется памяти для конструирования строк. Но все же иногда конструировать их надо.

Есть какие-то библиотеки для этого.
К примеру, в Glib есть gstring.h\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/gstring.h}}/
gstring.c\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/gstring.c}}. 

А в исходниках git можно найти strbuf.h\footnote{\url{https://github.com/git/git/blob/master/strbuf.h}}/
strbuf.c\footnote{\url{https://github.com/git/git/blob/master/strbuf.c}}. Собственно,
подобные Си-библиотеки очень похожи: они обеспечивают структуру данных, в которой есть некоторый буфер для строки, текущий размер буфера
и текущий размер строки в буфере. При помощи отдельных функций, можно добавлять новые строки или символы
в буфер, который, в свою очередь, будет автоматически увеличиваться или даже уменьшаться.

В strbuf.c из git есть даже ф-ция \IT{strbuf\_addf()}, работающая как sprintf(), 
но добавляющая строку-результат в буфер.

Так пользователь освобождается от головной боли связанной с выделением памяти.
При работе с этими библиотеками, практически невозможна ситуация переполнения буфера, если только не начать
работать со структурой самостоятельно.

Типичная последовательность работы с такими библиотеками, выглядит так:

\begin{itemize}
\item
Инициализация структуры strbuf или GString.

\item
Добавление строк и/или символов

\item
Имеем сконструированную строку. Используем как обычную Си-строку, записываем куда-то в файл, передаем по сети, итд

\item
Освобождаем структуру.
\end{itemize}

\subsection{Хранение длины строки}

Всегда хранить длину строки --- это было принято в реализациях ЯП Pascal. 
Не смотря на исходы святых войн\footnote{holy wars} между приверженцами Си и Pascal, все же, почти все библиотеки
для хранения строк и работы с ними, хранят также и текущую длину --- потому что удобства от этого перевешивают
необходимость пересчитывать это значение.

Например, \IT{strlen()} (подсчет длины строки) больше не нужен вообще, длина все время известна.
Конкатенация строк работает намного быстрее, потому что не нужно вычислять длину первой строки.
Ф-ция сравнения строк в самом начале может сравнить длины строк и если они не равны, тут же вернуть false,
не начиная сравнивание самих строк.

В Oracle RDBMS, в сетевых библиотеках, в функции работы со строками, зачастую передается строка и, 
отдельным аргументом, её длина\footnote{\url{http://blog.yurichev.com/node/64}}.
Это не очень эстетично, это выглядит избыточно, зато очень удобно.
Например, у нас есть некоторая ф-ция, которой нужно в начале узнать, какую строку ей передали:

\begin{lstlisting}
void f(char *color)
{
	if (strcmp (color, "red")==0)
		do_red();
	else if (strcmp (color, "green")==0)
		do_green();
	else if (strcmp (color, "blue")==0)
		do_blue();
	else if (strcmp (color, "orange")==0)
		do_orange();
	else if (strcmp (color, "yellow")==0)
		do_yellow();
	printf ("Unknown color!\n");
};
\end{lstlisting}

А вот если бы эта ф-ция имела длину входной строки, её можно было бы переписать так:

\begin{lstlisting}
void f(char *color, int color_len)
{
	switch (color_len)
	{
		case 3:
			if (strcmp (color, "red")==0)
				do_red();
			else 
				goto unknown_color;
			break;
		case 4:
			if (strcmp (color, "blue")==0)
				do_blue();
			else
				goto unknown_color;
			break;
		case 5:
			if (strcmp (color, "green")==0)
				do_green();
			else
				goto unknown_color;
			break;
		case 6:
			if (strcmp (color, "orange")==0)
				do_orange();
			else if (strcmp (color, "yellow")==0)
				do_yellow();
			else
				goto unknown_color;
			break;
		default:
				goto unknown_color;

	};

	return;

unknown_color:
	printf ("Unknown color!\n");
};
\end{lstlisting}

Конечно, с эстетической точки зрения, код выглядит ужасно.
Тем не менее, мы здорово сократили количество необходимых сравнений строк! Вероятно, для тех ситуаций, когда 
нужно как можно быстрее обрабатывать текстовые строки, такой подход может улучшить ситуацию.

