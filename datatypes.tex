\section{Типы данных}

\subsection{bool}

bool есть в Си++, но также он есть и в Си, начиная с C99 (stdbool.h).

В Windows API принят тип BOOL, это синоним int.

\subsection{Знаковые или беззнаковые?}

Знаковые типы (int, char) используются куда чаще беззнаковых (unsigned int, unsigned char).

Но с точки зрения документации кода, если вы объявляете переменную, которая никогда не будет хранить отрицательное
значение, в т.ч., индексы массивов, наверное лучше применять беззнаковый тип.
Например, в LLVM очень часто используется unsigned.

Если вы работаете с байтами, например, с байтами в памяти, то наверное лучше применять именно unsigned char.

К тому же, это может немного защититься от ошибок связанных с integer overflow\cite{Phrack3C0A}.

В качестве очень простого примера:

\begin{lstlisting}
#define MAX_BUFFER 1024

void f(int size)
{
	if (size>MAX_BUFFER_SIZE)
		die ("Too large!");
	void *p=malloc (size);
	...
};
\end{lstlisting}

Если size будет, например, $-1$, то malloc вызовется с аргументом \TT{0xffffffff} (это $4294967295$).
Конечно, нужно было бы добавить вторую проверку: \IT{if (size<0)}, но такая проверка выглядит здесь абсурдной.

Таким образом, здесь нужно было бы применить unsigned, либо даже тип \IT{size\_t}. 
\IT{size\_t} определяет тип, достаточно большой,
способный хранить размер любого, сколько угодно большого блока памяти.
На 32-битных архитектурах это обычно unsigned int,
а на 64-битных это unsigned int64.

\subsection{char или uint8\_t вместо int?}

Может показаться что если какая-то переменная всегда будет в пределах 0..100, то незачем выделять под нее 32-битный
int, а можно обойтись типом char или unsigned char. К тому же, такая переменная будет занимать в памяти в 4 раза меньше.

Это не так. Из-за выравнивания по 4-байтной границе (а в 64-битных архитектурах --- по 8-байтной), 
определяемые переменные типа char, занимают столько же места сколько и int. Конечно, компилятор мог бы отводить под
char только один байт, но тогда процессор тратил бы больше времени на обращение к ``невыровненным'' по границе байтам.
Работа с отдельными байтами может быть ``дороже'' и медленнее чем работа с 32-битными или 64-битными 
значениями потому что
регистры процессора обычно имеют ту же ширину что и разрядность процессора. И даже более того, RISC-процессоры 
(например ARM) вообще могут быть неспособны работать с отдельными байтами, потому что имеют только 32-битные регистры.

Таким образом, если вы раздумываете над типом для локальной переменной, то int/unsigned int будет лучше.

С другой стороны, переменные каких типов лучше использовать в структурах? Это поиск баланса между скоростью
и компактностью. С одной стороны, можно отвести char под небольшие переменные, под флаги, под enum, итд, но не следует
забывать, что доступ к этим переменным будет чуть медленнее. С другой стороны, под все переменные можно отводить
int, тогда работа со структурой будет быстрее, но она будет занимать в памяти больше места.

Например:

\begin{lstlisting}
struct
{
	char some_flags; // 1 byte
	void* ptr; // 4/8 bytes, offset: +1
} s;
\end{lstlisting}

Если скомпилировать это с упаковкой полей по 1-байтной границе, 
то доступ к \IT{some\_flags} в памяти будет возможно даже быстрее чем доступ к \IT{ptr}, потому что первое поле
выровнено по границе, а второе нет.

А если компилировать это с упаковкой полей по умолчанию, то компилятор отведет под первое поле 4 байта и смещение
у второго поля будет +4.

Резюмируя: если компактность и экономия памяти для вас важнее скорости, тогда нужно использовать 
\IT{char}, \IT{uint16\_t}, итд.

\subsection{x86-64 или AMD64}

На новых 64-битных x86-процессорах, тип int/unsigned int оставили 32-битным, вероятно, в целях совместимости.
Так что если вы хотите использовать 64-битные значения, можно использовать \IT{uint64\_t} или \IT{int64\_t}.

А указатели теперь, конечно, 64-битные.
