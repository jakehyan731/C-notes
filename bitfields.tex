\section{Битовые поля}

Это очень популярная штука в Си, да и не только.

Для задания булевых значений ``true'' или ``false'', можно передавать 1 или 0 в байте или в 32-битном регистре,
или в типе int, но это очень не экономно в плане расхода памяти. Намного удобнее передавать такие значения в отдельных
битах.

К примеру, стандартная ф-ция findfirst() возвращает структуру о найденном файле, где аттрибуты файла передаются
такими флагами:

\begin{lstlisting}
#define _A_NORMAL 0x00
#define _A_RDONLY 0x01
#define _A_HIDDEN 0x02
#define _A_SYSTEM 0x04
#define _A_SUBDIR 0x10
#define _A_ARCH 0x20
\end{lstlisting}

Конечно, передавать каждый аттрибут отдельной переменной bool было бы очень неэкономично.

И напротив, для указания флагов в ф-цию можно исползовать битовые поля. 
Например, CreateFile
\footnote{\url{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx}} из Windows API.

Для задания флагов, чтобы не запутаться и не опечататься в значениях каждого бита, можно писать так:

\begin{lstlisting}
#define FLAG1 (1<<0)
#define FLAG2 (1<<1)
#define FLAG3 (1<<2)
#define FLAG4 (1<<3)
#define FLAG5 (1<<4)
\end{lstlisting}

(Компилятор все равно всё это легко соптимизирует).

А чтобы было удобнее выставлять, удалять и проверять отдельный бит/флаг, можно использовать подобные макросы:

\begin{lstlisting}
#define IS_SET(flag, bit)       (((flag) & (bit)) ? true : false)
#define SET_BIT(var, bit)       ((var) |= (bit))
#define REMOVE_BIT(var, bit)    ((var) &= ~(bit))
\end{lstlisting}

С другой стороны, необходимо помнить, что операции выделения отдельного бита из значения типа int 
обычно даются процессору ``дороже'', чем работа с типом bool в 32-битном регистре. 
Так что, если скорость для вас намного критичнее чем
экономия памяти, можно попробовать использовать тип bool.

