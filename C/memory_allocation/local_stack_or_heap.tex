\subsection{Локальный стек или куча?}

Конечно, в локальном стеке выделение памяти происходит быстрее.

Например: в tracer\footnote{\url{http://yurichev.com/tracer-ru.html}} у меня есть дизассемблер\footnote{\url{https://github.com/dennis714/x86_disasm}} 
и эмулятор x86-процессора\footnote{\url{https://github.com/dennis714/bolt/blob/master/X86_emu.c}}.
Когда я писал дизассемблер на Си (я делал это после того как длительное время писал на ЯП 
более высокого уровня --- Python), 
я думал, что было бы неплохо, чтобы он сам выделял память под структуру, заполнял её
и возвращал указатель на нее, а в случае ошибки дизассемблирования, возвращал бы NULL. Эстетически, это 
неплохо смотрится, в стиле высокоуровневых ЯП, к тому же, такой код наверное легче читается. 
Однако, дизассемблер и эмулятор x86-процессора
работают в цикле, огромное количество раз в секунду и эффективность здесь более чем важна.
Так что, основной цикл у меня выглядит примерно так:

\begin{lstlisting}
while(true)
{
	struct disassembled_instruction;

	bool DA_success=disassemble(&disassembled_instruction...);
	if (DA_success==false)
		break;

	bool emulate_success=try_to_emulate(&disassembled_instruction);
	if (emulate_success==false)
		break;

};
\end{lstlisting}

Затрат на выделение памяти под структуры, описывающие дизассемблированную инструкцию, нет вовсе.
А иначе, нужно было бы на каждой итерации цикла вызывать malloc()/free(), каждая из которых, каждый раз,
работала бы со структурами кучи, итд.

Как известно, у x86-инструкций может быть вплоть до трех операндов, так что, в моей структуре, помимо
кода инструкции, есть также и информация о трех операндах. Конечно, можно было бы оформить её примерно так:

\begin{lstlisting}
struct disassembled_instruction
{
	int instruction_code;
	struct operand *op1;
	struct operand *op2;
	struct operand *op3;
};
\end{lstlisting}

... а в случае отсутствия какого либо операнда, пусть там будет NULL. Тем не менее, это снова выделение памяти в куче.

Так что у меня сделано примерно так:

\begin{lstlisting}
struct disassembled_instruction
{
	int instruction_code;
	int operands_total;
	struct operand op[3];
};
\end{lstlisting}

Такая структура занимает больше места в памяти. Ведь, как известно, трехоперандные инструкции очень редки в x86-коде,
а здесь у меня пустой третий операнд хранится всегда. Однако, лишних манипуляций с памятью не происходит.

Ну а если уж так сильно хочется сэкономить на третьем операнде, то можно не хранить третий операнд вовсе: нетрудно
вычислить размер структуры без одного операнда: \TT{sizeof(disassembled\_instruction) - sizeof(struct operand)} 
и скопировать его куда-то, где он должен храниться.
Ведь никто не запрещает нам использовать (и хранить) не всю структуру а только её часть.
А ф-ции работы с этой структурой могут не трогать в памяти третий операнд вовсе и, таким образом, ошибок не будет.

И даже более того: я специально сделал дизассемблер именно так, чтобы он мог принимать на вход не инициализированную
структуру, и мог работать даже если там осталась информация от предыдущих вызовов.

Возможно, это уже слишком, но вы поняли идею.

Таким образом, если вы выделяете память под небольшие структуры зараннее известного размера, или если скорость
очень важна, то лучше подумать насчет выделения в локальном стеке.

