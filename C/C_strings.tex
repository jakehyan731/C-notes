\chapter{Строки в Си}

В Си нет встроенных возможностей для удобной работы со строками, такими, какие имеются в ЯП более
высокого уровня.

Часто жалуются на неудобную
конкатенацию строк (то есть, склеивание) в Си при помощи функции strcat(). Также, многих раздражает sprintf(),
под которых нельзя толком зараннее предсказать, сколько нужно выделять памяти. Копирование строк при помощи
strcpy() также неудобно --- нужно думать, сколько же выделить байт под буфер. Помимо всего прочего, неудобная
работа со строками в Си, это источник огромного количества уязвимостей в ПО, связанных с переполнениями буфера\cite[1.14.2]{REBook}.

Прежде всего, нужно задать себе вопрос, какие операции со строками нам нужны.
Конкатенация (склеивание) нужна чтобы 1) выдавать в лог сообщения; 2) конструировать строки и записывать их куда-то.

Для 1) можно использовать потоки (streams) --- не конструируя строку, выдавать её по порциям, например:

\begin{lstlisting}
printf ("Date: ");
dump_date(stdout, date);
printf (" a=");
dump_a(stdout, a);
printf ("\n");
\end{lstlisting}

Подобное заменяется в Си++ выводом в ostream:

\begin{lstlisting}
cout << "Date: " << Date_ToString(date) << " a=" << a_ToString(a) << "\n";
\end{lstlisting}

Так быстрее и меньше требуется памяти для конструирования строк.

Кстати, ошибкой является писать так:

\begin{lstlisting}
cout << "Date: " + Date_ToString(date) + " a=" + a_ToString(a) + "\n";
\end{lstlisting}

Для неспешного вывода в лог небольшого кол-ва сообщений это нормально, но если таких строк очень много, то будут
накладные расходы на их конкатенацию. \\
\\
Но все же строки иногда конструировать надо.

Есть какие-то библиотеки для этого.
К примеру, в Glib\footnote{\url{https://developer.gnome.org/glib/}} есть 
gstring.h\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/gstring.h}}/
gstring.c\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/gstring.c}}. 

\label{strbuf}
А в исходниках git можно найти strbuf.h\footnote{\url{https://github.com/git/git/blob/master/strbuf.h}}/
strbuf.c\footnote{\url{https://github.com/git/git/blob/master/strbuf.c}}. Собственно,
подобные Си-библиотеки очень похожи: они обеспечивают структуру данных, в которой есть некоторый буфер для строки, текущий размер буфера
и текущий размер строки в буфере. При помощи отдельных функций, можно добавлять новые строки или символы
в буфер, который, в свою очередь, будет автоматически увеличиваться или даже уменьшаться.

В \IT{strbuf.c} из git есть даже ф-ция \IT{strbuf\_addf()}, работающая как \IT{sprintf()}, 
но добавляющая строку-результат в буфер.

Так пользователь освобождается от головной боли связанной с выделением памяти.
При работе с этими библиотеками, практически невозможна ситуация переполнения буфера, если только не начать
работать со структурой самостоятельно.

Типичная последовательность работы с такими библиотеками, выглядит так:

\begin{itemize}
\item
Инициализация структуры strbuf или GString.

\item
Добавление строк и/или символов.

\item
Имеем сконструированную строку. Используем как обычную Си-строку, записываем куда-то в файл, передаем по сети, итд.

\item
Освобождаем структуру.
\end{itemize}

Кстати, конструирование строк чем-то напоминает 
Buffer\footnote{\url{http://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html}}, 
ByteBuffer\footnote{\url{http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html}} и 
CharBuffer\footnote{\url{http://docs.oracle.com/javase/7/docs/api/java/nio/CharBuffer.html}} в Java.

\section{Хранение длины строки}

Всегда хранить длину строки --- это было принято в реализациях ЯП Pascal. 
Не смотря на исходы святых войн\footnote{holy wars} между приверженцами Си и Pascal, все же, почти все библиотеки
для хранения строк и работы с ними, хранят также и текущую длину --- потому что удобства от этого перевешивают
необходимость пересчитывать это значение.

Например, \IT{strlen()} (подсчет длины строки) больше не нужен вообще, длина все время известна.
Конкатенация строк работает намного быстрее, потому что не нужно вычислять длину первой строки.
Ф-ция сравнения строк в самом начале может сравнить длины строк и если они не равны, тут же вернуть false,
не начиная сравнивание самих строк.

В Oracle RDBMS, в сетевых библиотеках, в функции работы со строками, зачастую передается строка и, 
отдельным аргументом, её длина\footnote{\url{http://blog.yurichev.com/node/64}}.
Это не очень эстетично, это выглядит избыточно, зато очень удобно.
Например, у нас есть некоторая ф-ция, которой нужно в начале узнать, какую строку ей передали:

\begin{lstlisting}
void f(char *color)
{
	if (strcmp (color, "red")==0)
		do_red();
	else if (strcmp (color, "green")==0)
		do_green();
	else if (strcmp (color, "blue")==0)
		do_blue();
	else if (strcmp (color, "orange")==0)
		do_orange();
	else if (strcmp (color, "yellow")==0)
		do_yellow();
	printf ("Unknown color!\n");
};
\end{lstlisting}

А вот если бы эта ф-ция имела длину входной строки, её можно было бы переписать так:

\begin{lstlisting}
void f(char *color, int color_len)
{
	switch (color_len)
	{
		case 3:
			if (strcmp (color, "red")==0)
				do_red();
			else 
				goto unknown_color;
			break;
		case 4:
			if (strcmp (color, "blue")==0)
				do_blue();
			else
				goto unknown_color;
			break;
		case 5:
			if (strcmp (color, "green")==0)
				do_green();
			else
				goto unknown_color;
			break;
		case 6:
			if (strcmp (color, "orange")==0)
				do_orange();
			else if (strcmp (color, "yellow")==0)
				do_yellow();
			else
				goto unknown_color;
			break;
		default:
				goto unknown_color;

	};

	return;

unknown_color:
	printf ("Unknown color!\n");
};
\end{lstlisting}

Конечно, с эстетической точки зрения, код выглядит ужасно.
Тем не менее, мы здорово сократили количество необходимых сравнений строк! Вероятно, для тех ситуаций, когда 
нужно как можно быстрее обрабатывать текстовые строки, такой подход может улучшить ситуацию.

\section{Возврат строки}

Если некая ф-ция должна вернуть строку, имеются такие возможности:

\begin{itemize}
\item
Возврат строки-константы, это самое простое и быстрое.

\item
Возврат строки через глобальный массив символов. Недостаток: массив один и каждый вызов ф-ции перезаписывает
его содержимое.

\item
Возврат строки через буфер, заданный в аргументах ф-ции. Недостаток: нужно также передавать и длину буфера.

\item
Выделяем буфер нужного размера сами, записываем туда строку, возвращаем указатель. Недостаток: тратятся ресурсы
на выделение памяти.

\item
Записываем строку в уже рассмотренный strbuf или GString или иную другую структуру, указатель на которую был
передан в аргументах.

\end{itemize}

Первый вариант очень прост. Например:

\begin{lstlisting}
const char* get_month_name (int month)
{
	switch (month)
	{
	case 1: return "January";
	case 2: return "February";
	case 3: return "March";
	case 4: return "April";
	case 5: return "May";
	case 6: return "June";
	case 7: return "July";
	case 8: return "August";
	case 9: return "September";
	case 10: return "October";
	case 11: return "November";
	case 12: return "December";
	default: return "Unknown month!";
	};
};
\end{lstlisting}

Можно даже еще проще:

\begin{lstlisting}
const char* month_names[]={
	"January", "February", "March", "April", "May", "June", "July", "August",
	"September", "October", "November", "December" };

const char* get_month_name (int month)
{
	if (month>=1 && month<=12)
		return month_names[month-1];

	return "Unknown month!";
};
\end{lstlisting}

Насчет второго варианта, в git в hex.c\footnote{\url{https://github.com/git/git/blob/master/hex.c}} можно найти такое:

\begin{lstlisting}
char *sha1_to_hex(const unsigned char *sha1)
{
	static int bufno;
	static char hexbuffer[4][50];
	static const char hex[] = "0123456789abcdef";
	char *buffer = hexbuffer[3 & ++bufno], *buf = buffer;
	int i;

	for (i = 0; i < 20; i++) {
		unsigned int val = *sha1++;
		*buf++ = hex[val >> 4];
		*buf++ = hex[val & 0xf];
	}
	*buf = '\0';

	return buffer;
}
\end{lstlisting}

Строка возвращается фактически через глобальную переменную, объявление её как static внутри ф-ции просто напросто
обеспечивает доступ к ней только из этой ф-ции. Но вот недостаток: после вызова \IT{sha1\_to\_hex()} вы не можете
вызвать её повторно для получения второй строки до тех пор, пока не используете как-то первую, ведь она
затрется! Для того чтобы решить эту проблему здесь, по видимому, сделали сразу 4 буфера и каждый раз строка
возвращается в следующем. Но имейте ввиду --- так можно делать если только вы уверены в том что вы делаете,
это код на уровне ``грязного хака''.
Если вы
вызовете эту ф-цию 5 раз и вам нужно будет использовать как-то строку полученную при первом вызове, это может
привести к трудновыявляемой ошибке.

Кстати, обратите также внимание на то что переменная \IT{bufno} не инициализируется, потому что используются только 
2 младших её бита, к тому же, не важно, какое значение переменная будет содержать в самом начале!

\section{Определение строк}

\label{heredoc}
Малоизвестная возможность Си, длинные строки можно определять так:

\begin{lstlisting}
const char* long_line="line 1"
	"line 2"
	"line 3"
	"line 4"
	"line 5";

...

printf ("Some Utility v0.1\n"
	"Usage: %s parameters\n"
	"\n"
	"Authors:...\n", argv[0]);
\end{lstlisting}

Это отдаленно напоминает ``here document''\footnote{\url{https://en.wikipedia.org/wiki/Here_document}} в 
UNIX-шеллах и Perl.

