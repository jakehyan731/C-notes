\section{Списки в Си.}

Списки это связный набор элементов. Односвязный список --- это когда у каждого элемента есть ссылка на следующий.
Двусвязный список --- когда у элемента есть ссылки на следующий и на предыдущий.

У списков есть серьезное преимущество перед массивами: в список легко добавлять элемент в произвольное место,
так и удалять. В качестве недостатков: тратится много памяти для поддержания самих структур списка, а также
нет возможности индексировать его, как массив.

\subsection{Односвязный список}

Его сделать очень легко. В структуре предназначенной для связывания в список, достаточно добавить где-то
ссылку на следующий элемент, обычно это поле называется next:

\begin{lstlisting}
struct some_object
{
	...
	...
	struct some_object* next;
};
\end{lstlisting}

NULL в next означает что этот элемент является последним.

Операция прохода по такому списку становится очень простой:

\begin{lstlisting}
for (struct some_object *i=list; i!=NULL; i=i->next)
	...
\end{lstlisting}

Для вставки нового элемента, нужно вначале найти последний элемент:

\begin{lstlisting}
for (struct some_object *i=list; i!=NULL; i=i->next);
struct some_object *last_element=i;
\end{lstlisting}

... а затем, создав новую структуру, добавить указатель на нее в next:

\begin{lstlisting}
struct some_object *new_object=calloc(1, sizeof(struct some_object));
// populate new_object with data
last_element->next=new_object;
\end{lstlisting}

calloc() отличается от malloc() тем что обнуляет всё выделенное место, а значит в поле next нового
элемента сразу будет NULL\footnote{Об ``инициализации'' структур, читайте также здесь\ref{COOPInit}.}.

Поиск нужного элемента это просто проход по всему списку до тех пор, пока не найдется то что нужно.

Удаление элемента: найти предыдущий элемент и следующий, 
у предыдущего в next установить указатель на следующий элемент, 
затем освободить блок памяти выделенный для текущего элемента.

Самый первый элемент списка называется ``list head''. Структуру самого первого элемента можно объявлять как локальную
или глобальную переменную. Но тогда удалять первый элемент списка будет неудобно. А с другой стороны,
можно объявлять указатель на первый элемент списка, тогда будет проще этому указателю присвоить другой элемент,
который будет первым.

\subsection{Двусвязный список}

Это почти то же самое, только, помимо указателя на следующий элемент, хранится еще и указатель на предыдущий.
Если элемент первый, то указатель может быть NULL, либо он может указывать сам на себя (кому как удобнее).

Работая с двусвязным списком, легче находить предыдущие элементы, например, когда нужно удалить какой-то элемент.
А также можно перебирать элементы с конца списка до начала.
Но памяти на это тратится немного больше.

\subsection{Windows API}

Здесь, да и много где в ядре Windows, применяются две примитивные структуры:

\begin{lstlisting}
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;
\end{lstlisting}

Эти структуры нельзя назвать самостоятельными, они скорее предназначены для встраивания в другие структуры.
Например, вам нужно объеденить в список структуру описывающую цвет:

\begin{lstlisting}
struct color
{
	int R;
	int G;
	int B;
	LIST_ENTRY list;
};
\end{lstlisting}

Теперь в вашей структуре есть также и ссылка на предыдущий элемент и на следующий.
Для работы со структурами использующие эти списки, в Windows есть набор ф-ций
\footnote{\url{http://msdn.microsoft.com/en-us/library/windows/hardware/ff563802(v=vs.85).aspx}}.

\subsection{Linux}

В ядре Linux работа с простыми двусвязными списками, описывается в файле /include/linux/list.h
\footnote{\url{http://lxr.free-electrons.com/source/include/linux/list.h}}.

Там это много где используется, в ядре 3.12 по крайней мере ~2900 упоминаний ``struct list\_head''.

\subsection{Glib}

Напрашивается мысль, а нельзя ли выделить отдельную структуру для элемента списка, и не встраивать лишних полей
в свои структуры? Можно, например, так сделано в glist.h
\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/glist.h} 
\url{https://developer.gnome.org/glib/2.37/glib-Doubly-Linked-Lists.html}} в glib:

\begin{lstlisting}
struct _GList
{
  gpointer data;
  GList *next;
  GList *prev;
};
\end{lstlisting}

data может указывать на какой угодно объект, на любую существующую структуру, в которой вы ничего не хотите менять.
Конечно, с эстетической точки зрения, это лучше. Но нельзя забывать, что тогда на каждый элемент вашего списка,
будет приходится уже два выделенных блока памяти + еще затраты на поддержания самих блоков памяти\ref{HeapOverhead}. \\
\\
Таким образом, подобное решение оправдано там, где экономия памяти менее важна.

