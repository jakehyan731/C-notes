\section{Строки в Си}

В Си нет встроенных возможностей для удобной работы со строками, такими, какие имеются в ЯП более
высокого уровня.

Часто жалуются на неудобную
конкатенацию строк (то есть, склеивание) в Си при помощи функции strcat(). Также, многих раздражает sprintf(),
под которых нельзя толком зараннее предсказать, сколько нужно выделять памяти. Копирование строк при помощи
strcpy() также неудобно --- нужно думать, сколько же выделить байт под буфер. Помимо всего прочего, неудобная
работа со строками в Си, это источник огромного количества уязвимостей в ПО, связанных с переполнениями буфера\cite[1.14.2]{REBook}.

Прежде всего, нужно задать себе вопрос, какие операции со строками нам нужны.
Конкатенация (склеивание) нужна чтобы 1) выдавать в лог сообщения; 2) конструировать строки и записывать их куда-то.

Для 1) можно использовать потоки (streams) --- не конструируя строку, выдавать её по порциям, например:

\begin{lstlisting}
printf ("Date: ");
dump_date(stdout, date);
printf (" a=");
dump_a(stdout, a);
printf ("\n");
\end{lstlisting}

Подобное заменяется в Си++ выводом в ostream:

\begin{lstlisting}
cout << "Date: " << Date_ToString(date) << " a=" << a_ToString(a) << "\n";
\end{lstlisting}

Так быстрее и меньше требуется памяти для конструирования строк.

Кстати, ошибкой является писать так:

\begin{lstlisting}
cout << "Date: " + Date_ToString(date) + " a=" + a_ToString(a) + "\n";
\end{lstlisting}

Для неспешного вывода в лог небольшого кол-ва сообщений это нормально, но если таких строк очень много, то будут
накладные расходы на их конкатенацию. \\
\\
Но все же строки иногда конструировать надо.

Есть какие-то библиотеки для этого.
К примеру, в Glib\footnote{\url{https://developer.gnome.org/glib/}} есть 
gstring.h\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/gstring.h}}/
gstring.c\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/gstring.c}}. 

\label{strbuf}
А в исходниках git можно найти strbuf.h\footnote{\url{https://github.com/git/git/blob/master/strbuf.h}}/
strbuf.c\footnote{\url{https://github.com/git/git/blob/master/strbuf.c}}. Собственно,
подобные Си-библиотеки очень похожи: они обеспечивают структуру данных, в которой есть некоторый буфер для строки, текущий размер буфера
и текущий размер строки в буфере. При помощи отдельных функций, можно добавлять новые строки или символы
в буфер, который, в свою очередь, будет автоматически увеличиваться или даже уменьшаться.

В \IT{strbuf.c} из git есть даже ф-ция \IT{strbuf\_addf()}, работающая как \IT{sprintf()}, 
но добавляющая строку-результат в буфер.

Так пользователь освобождается от головной боли связанной с выделением памяти.
При работе с этими библиотеками, практически невозможна ситуация переполнения буфера, если только не начать
работать со структурой самостоятельно.

Типичная последовательность работы с такими библиотеками, выглядит так:

\begin{itemize}
\item
Инициализация структуры strbuf или GString.

\item
Добавление строк и/или символов.

\item
Имеем сконструированную строку. Используем как обычную Си-строку, записываем куда-то в файл, передаем по сети, итд.

\item
Освобождаем структуру.
\end{itemize}

Кстати, конструирование строк чем-то напоминает 
Buffer\footnote{\url{http://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html}}, 
ByteBuffer\footnote{\url{http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html}} и 
CharBuffer\footnote{\url{http://docs.oracle.com/javase/7/docs/api/java/nio/CharBuffer.html}} в Java.

\subsection{Хранение длины строки}

Всегда хранить длину строки --- это было принято в реализациях ЯП Pascal. 
Не смотря на исходы святых войн\footnote{holy wars} между приверженцами Си и Pascal, все же, почти все библиотеки
для хранения строк и работы с ними, хранят также и текущую длину --- потому что удобства от этого перевешивают
необходимость пересчитывать это значение.

Например, \IT{strlen()} (подсчет длины строки) больше не нужен вообще, длина все время известна.
Конкатенация строк работает намного быстрее, потому что не нужно вычислять длину первой строки.
Ф-ция сравнения строк в самом начале может сравнить длины строк и если они не равны, тут же вернуть false,
не начиная сравнивание самих строк.

В Oracle RDBMS, в сетевых библиотеках, в функции работы со строками, зачастую передается строка и, 
отдельным аргументом, её длина\footnote{\url{http://blog.yurichev.com/node/64}}.
Это не очень эстетично, это выглядит избыточно, зато очень удобно.
Например, у нас есть некоторая ф-ция, которой нужно в начале узнать, какую строку ей передали:

\lstinputlisting{C/strings/strcmp1.c}

А вот если бы эта ф-ция имела длину входной строки, её можно было бы переписать так:

\lstinputlisting{C/strings/strcmp2.c}

Конечно, с эстетической точки зрения, код выглядит ужасно.
Тем не менее, мы здорово сократили количество необходимых сравнений строк! Вероятно, для тех ситуаций, когда 
нужно как можно быстрее обрабатывать текстовые строки, такой подход может улучшить ситуацию.

\input{C/strings/return}
\input{C/strings/std_func}

\subsection{Unicode}

Unicode это важно! Наиболее популярные способы его применения это:

\begin{itemize}
\item UTF-8
Популярно в UNIX-системах. Сильное приемущество: можно продолжать пользоваться стандартными ф-циями для
обработки строк.

\item UTF-16
Используется в Windows API.
\end{itemize}

\subsubsection{UTF-16}

Под каждый символ отводят 16-битный тип \IT{wchar\_t}.

Для объявления строк с таким типом, используется макрос L:

\begin{lstlisting}
L"hello world"
\end{lstlisting}

Для работы с wchar\_t вместо char, имеется целый класс функций-двойников с символом w в названии,
например: fwprintf(), wcscmp(), wcslen(), iswalpha().

\paragraph{Windows}

В Windows, если некто хочет писать программу сразу в двух версиях, с использованием Unicode и без,
для этого есть тип tchar, в зависимости от объявленной переменной препроцессора UNICODE, 
он будет либо char либо wchar\_t\footnote{Сборка с Unicode и без была популярна во времена популярности
как Windows NT/2000/XP так и Windows 95/98/ME. Вторая линейка плохо поддерживала Unicode}.
Для этого же имеется макрос \TT{\_T(...)}:

\begin{lstlisting}
_T("hello world")
\end{lstlisting}

В зависимости от выставленной переменной препроцессора UNICODE, она будет объявлена как char либо wchar\_t.

В заголовочном файле tchar.h есть масса ф-ций, меняющих свою функцию в зависимости от этой переменной.

\subsection{Списки строк}

Самый простой список строк, это просто набор строк оканчивающийся нулем.
Например, в Windows API, в библиотеке Common Dialogs, 
так\footnote{\url{http://msdn.microsoft.com/en-us/library/windows/desktop/ms646829(v=vs.85).aspx}} 
передаются список допустимых расширений файлов для диалогового окна:

\begin{lstlisting}
// Initialize OPENFILENAME
ZeroMemory(&ofn, sizeof(ofn));
...
ofn.lpstrFilter = "All\0*.*\0Text\0*.TXT\0";
...

// Display the Open dialog box. 

if (GetOpenFileName(&ofn)==TRUE) 
	...
\end{lstlisting}

