\label{COOP}
\section{\COOPname}

Как известно, в Си нет поддержки ООП, она есть в Си++, тем не менее, в чистом Си вполне
можно программировать в стиле ООП.

ООП, коротко говоря, это явное разделение на объекты и методы. 
В Си структуры легко могут представляться объектами, а обычные ф-ции --- методами.

\subsection{Инициализация структур}
\label{COOPInit}

В Си++ у классов имеются конструкторы. Если вам нужно каким-то особенным образом инициализировать
структуру, вам и в Си придется делать подобную ф-цию. Но если структура простая, то её можно
инициализировать при помощи calloc()\footnote{Это тоже самое что и malloc() + заполнение выделенной
памяти нулями} 
либо bzero()\ref{bzero}.

Все int-переменные становятся нулями. Нулевое значение bool в C99\ref{C99} и C++ это false, 
так же как и BOOL в Windows API. Все указатели становятся NULL. И даже вещественный
ноль представляемый в формате IEEE 754 это также все ноли во всех битах.

Если в структуре присутствуют указатели на другие структуры, то NULL может означать ``отсутствие объекта''.

\subsection{Деинициализация структур}

Если в структуре есть ссылки на другие структуры, то их нужно освобождать. В простом случае,
обычным вызовом free(). Кстати, вот почему free() может принимать на вход NULL и ничего в этом случае
не делать, это чтобы можно было просто писать \TT{free(s->field)} вместо 
\TT{if (s->field) free(s->field)}, так короче.

\subsection{Копирование структур}

Если структура простая, то её можно копировать обычным побайтовым копированием memcpy()\ref{memcpy}.
Если в такой манере скопировать структуру, в которой есть указатели на другие структуры,
то это будет называться \IT{shallow copy}\footnote{\url{https://en.wikipedia.org/wiki/Object_copy}}. 
И напротив, \IT{deep copy} --- это копирование структуры
плюс всех связанных с ней структур (это дольше).

Вот почему может быть удобнее хранить строку в структуре как обычный массив символов фиксированной длины.
Такого, например, очень много в Windows API. Такую структуру легко скопировать, её хранение
требует меньших накладных расходов\footnote{overhead} в куче. 
Но с другой стороны, придется согласиться с ограничением на длину строки.

Помимо всего прочего, структуру можно копировать просто так: \TT{s1=s2} --- в итоге генерируется код,
копирющий все поля по порядку. И это наверное легче читается чем вызов memcpy() на этом же месте.

\subsection{Инкапсуляция}

Си++ предлагает инкапсуляцию (сокрытие информации). Например, вы не можете
написать программу модифицирующую защищенное поле в классе, 
это защита на стадии компиляции\cite[1.7.3]{REBook}.

В Си этого нет, поэтому тут нужно больше дисциплины.

Впрочем, можно попытаться ``защитить'' структуру ``от посторонних глаз''. Например, в glib,
имеется библиотека для работы с деревьями. В заголовочном файле 
gtree.h\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/gtree.h}} нет описания самой структуры
(она есть только в gtree.c\footnote{\url{https://github.com/GNOME/glib/blob/master/glib/gtree.c}}), 
а есть только forward declaration\ref{forwarddeclaration}. Так можно понадеятся что
пользователи GTree постараются не пользоваться отдельными полями в структуре.

Но у такого метода есть и обратная сторона: могут быть крохотные однострочные ф-ции вроде 
``вернуть длину строки'' в strbuf\ref{strbuf}, например:

\begin{lstlisting}
typedef struct _strbuf
{
    char *buf;
    unsigned strlen;
    unsigned buflen;
} strbuf;

unsigned strbuf_get_len(strbuf *s)
{
	return s->strlen;
};
\end{lstlisting}

Если компилятору на стадии компиляции доступно и описание структуры и тело ф-ции, то в каком-то месте,
вместо вызова strbuf\_get\_len() он может сделать эту ф-цию как inline-овую, вставить её тело прямо на том
же место и сэкономить на вызове другой ф-ции. Но если эта информация компилятору недоступна, то он
оставит вызов strbuf\_get\_len() как есть.

То же самое касается поля buf в структуре strbuf. Компилятор может генерировать куда более эффективный
код, если этот код сможет обращаться к полям структур на прямую, а не вызывать суррогатные 
функции-``методы''.

