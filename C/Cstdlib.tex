\chapter{\IFRU{Стандартные библиотеки Си/Си++}{C/C++ standard library}}

\section{assert}

Как известно, этот макрос часто используется для валидации
\footnote{используется также такой термин как ``инвариант'' и ``sanitization'' в англ.яз.} заданных значений. 
Например, если ваша ф-ция
работает с датой, вы, вероятно, захотите написать в её начале что-то вроде \IT{assert (month>=1 \&\& month<=12)}.

Вот то о чем нужно помнить: стандартный макрос assert() доступен только в отладочных (debug) сборках. В release
все выражения как бы исчезают. Поэтому писать, например, \IT{assert(f=malloc(...))} неверно. Впрочем,
вы возможно захотите использовать что-то вроде \IT{assert(object->get\_something()==123)}.

В макросах assert можно также указывать небольшие сообщения об ошибках: 
вы увидите их если assert() ``не сойдется''. 
Например, в исходниках LLVM\footnote{\url{http://llvm.org/}} можно встретить такое:

\begin{lstlisting}
assert(Index < Length && "Invalid index!");
...
assert(i + Count <= M && "Invalid source range");
...
assert(j + Count <= N && "Invalid dest range");
\end{lstlisting}

Текстовая строка имеет тип \IT{const char*}, и она никогда не NULL. 
Таким образом, можно дописать к любому выражению \IT{... \&\& true} не меняя его смысл.

\section{Разница между stdout и stderr}

\IT{stdout} это то что выводится на консоль при помощи вызова \IT{printf()}.
\IT{stdout} это буферизированный вывод,
так что, пользователь, обычно того не зная, видит вывод порциями. Бывает так что программа выдает
что-то используя \IT{printf()} либо \IT{cout} и тут же падает.
Если это попадает в буфер, но буфер не успевает
``сброситься'' (flush) в консоль, то пользователь ничего не увидит. Это бывает неудобно.
Таким образом, для вывода более важной информации, в том числе отладочной, удобнее использовать \IT{stderr}.

\IT{stderr} это не буферизированный вывод, и всё что попадает в этот поток при помощи 
\TT{fprintf(stderr,...)} либо \IT{cerr}, появляется в консоли тут же.

Не следует также забывать, что из-за отсутствия буфера, вывод в \IT{stderr} медленнее.

Чтобы направлять \IT{stderr} в другой файл при запуске процесса, можно указывать:

\begin{lstlisting}
process 2> debug.txt
\end{lstlisting}

... это направит вывод \IT{stderr} в заданный файл (потому что номер этого потока -- 2).

\section{UNIX time}

В UNIX-среде очень популярно представление даты и времени в формате UNIX time.
Это просто 32-битное число, показывающее
количество прошедших секунд с 1-го января 1970-го года.

В качестве положительных сторон: 1) очень легко хранить это 32-битное число; 2) очень легко вычислять разницу дат;
3) невозможно закодировать неверные даты и время, такие как 32-е января, 29-е февраля невысокосных годов, 
25 часов 62 минуты.

В качестве отрицательных сторон: 1) нельзя закодировать дату до 1970-го года.

В наше время, если использовать UNIX time, тем не менее, следует помнить что ``срок его действия'' истечет
в 2038-м году, именно тогда 32-битное число переполнится, то есть, пройдет $2^{32}$ секунд с 1970-го года.
Так что, для этого следует использовать 64-битное значение, т.е., time64.

% ? NtQuerySystemTime http://msdn.microsoft.com/en-us/library/windows/desktop/ms724512(v=vs.85).aspx

\input{C/scanf}

\label{memcpy}
\section{memcpy()}

Поначалу трудно запомнить порядок аргументов в ф-циях memcpy(), strcpy(). Чтобы было легче, можно представлять
знак ``='' (``равно'') между аргументами.

\label{bzero}
\section{bzero() и memset()}

bzero() это ф-ция просто обнуляющая блок памяти.
Для этого обычно используют memset(). Но у memset() есть неприятная особенность, легко перепутать второй
и третий аргументы местами, и компилятор промолчит, потому что байт для заполнения всего блока задается как int.

К тому же, имя ф-ции bzero легче читается.

С другой стороны, её нет в стандарте POSIX.

\input{C/printf}

\section{strstr() и memmem()}

strstr() применяется для поиска строки в другой строке, либо чтобы узнать, есть ли там такая строка вообще.

memmem() можно применять с этими же целями, но для поиска по буферу, в котором могут быть нули,
либо по части строки.

\label{memchr}
\section{strchr() и memchr()}

strchr() применяется для поиска символа в строке, либо чтобы узнать, есть ли там такой символ вообще.

memchr() можно применять с этими же целями, но для поиска по части строки.

\section{atexit()}

При помощи atexit() можно добавить ф-цию, автоматически вызываемую перед выходом из вашей программы.
Кстати, программы на Си++ именно при помощи atexit() добавляют деструкторы глобальных объектов.

Можно попробовать:

\begin{lstlisting}
#include <string>

std::string s="test";

int main()
{
};
\end{lstlisting}

В листинге на ассемблере найдем конструктор этого глобального объекта:

\begin{lstlisting}[caption=MSVC 2010]
??__Es@@YAXXZ PROC					; `dynamic initializer for 's'', COMDAT
; Line 3
	push	ebp
	mov	ebp, esp
	push	OFFSET $SG22192
	mov	ecx, OFFSET ?s@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; s
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??__Fs@@YAXXZ			; `dynamic atexit destructor for 's''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Es@@YAXXZ ENDP					; `dynamic initializer for 's''

??__Fs@@YAXXZ PROC					; `dynamic atexit destructor for 's'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?s@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; s
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	ebp
	ret	0
??__Fs@@YAXXZ ENDP					; `dynamic atexit destructor for 's''
\end{lstlisting}

Конструктор, конструируя, также регистрирует деструктор объекта в atexit().

\section{atoi(), atof(), strtod(), strtof()}

Ф-ции atoi/atof не могут сигнализировать об ошибке, а strtod/strtof, делая то же самое --- могут.

\input{C/bsearch.tex}

