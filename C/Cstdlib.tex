\chapter{\IFRU{Стандартные библиотеки Си/Си++}{C/C++ standard library}}

\section{assert}

Как известно, этот макрос часто используется для валидации
\footnote{используется также такой термин как ``инвариант'' и ``sanitization'' в англ.яз.} заданных значений. 
Например, если ваша ф-ция
работает с датой, вы, вероятно, захотите написать в её начале что-то вроде \IT{assert (month>=1 \&\& month<=12)}.

Вот то о чем нужно помнить: стандартный макрос assert() доступен только в отладочных (debug) сборках. В release
все выражения как бы исчезают. Поэтому писать, например, \IT{assert(f=malloc(...))} неверно. Впрочем,
вы возможно захотите использовать что-то вроде \IT{assert(object->get\_something()==123)}.

В макросах assert можно также указывать небольшие сообщения об ошибках: 
вы увидите их если assert() ``не сойдется''. 
Например, в исходниках LLVM\footnote{\url{http://llvm.org/}} можно встретить такое:

\begin{lstlisting}
assert(Index < Length && "Invalid index!");
...
assert(i + Count <= M && "Invalid source range");
...
assert(j + Count <= N && "Invalid dest range");
\end{lstlisting}

Текстовая строка имеет тип \IT{const char*}, и она никогда не NULL. 
Таким образом, можно дописать к любому выражению \IT{... \&\& true} не меняя его смысл.

\section{Разница между stdout и stderr}

\IT{stdout} это то что выводится на консоль при помощи вызова \IT{printf()}.
\IT{stdout} это буферизированный вывод,
так что, пользователь, обычно того не зная, видит вывод порциями. Бывает так что программа выдает
что-то используя \IT{printf()} либо \IT{cout} и тут же падает.
Если это попадает в буфер, но буфер не успевает
``сброситься'' (flush) в консоль, то пользователь ничего не увидит. Это бывает неудобно.
Таким образом, для вывода более важной информации, в том числе отладочной, удобнее использовать \IT{stderr}.

\IT{stderr} это не буферизированный вывод, и всё что попадает в этот поток при помощи 
\TT{fprintf(stderr,...)} либо \IT{cerr}, появляется в консоли тут же.

Не следует также забывать, что из-за отсутствия буфера, вывод в \IT{stderr} медленнее.

Чтобы направлять \IT{stderr} в другой файл при запуске процесса, можно указывать:

\begin{lstlisting}
process 2> debug.txt
\end{lstlisting}

... это направит вывод \IT{stderr} в заданный файл (потому что номер этого потока -- 2).

\section{UNIX time}

В UNIX-среде очень популярно представление даты и времени в формате UNIX time.
Это просто 32-битное число, показывающее
количество прошедших секунд с 1-го января 1970-го года.

В качестве положительных сторон: 1) очень легко хранить это 32-битное число; 2) очень легко вычислять разницу дат;
3) невозможно закодировать неверные даты и время, такие как 32-е января, 29-е февраля невысокосных годов, 
25 часов 62 минуты.

В качестве отрицательных сторон: 1) нельзя закодировать дату до 1970-го года.

В наше время, если использовать UNIX time, тем не менее, следует помнить что ``срок его действия'' истечет
в 2038-м году, именно тогда 32-битное число переполнится, то есть, пройдет $2^{32}$ секунд с 1970-го года.
Так что, для этого следует использовать 64-битное значение, т.е., time64.

% ? NtQuerySystemTime http://msdn.microsoft.com/en-us/library/windows/desktop/ms724512(v=vs.85).aspx

\label{memcpy}
\section{memcpy()}

Поначалу трудно запомнить порядок аргументов в ф-циях memcpy(), strcpy(). Чтобы было легче, можно представлять
знак ``='' (``равно'') между аргументами.

\label{bzero}
\section{bzero() и memset()}

bzero() это ф-ция просто обнуляющая блок памяти.
Для этого обычно используют memset(). Но у memset() есть неприятная особенность, легко перепутать второй
и третий аргументы местами, и компилятор промолчит, потому что байт для заполнения всего блока задается как int.

К тому же, имя ф-ции bzero легче читается.

С другой стороны, её нет в стандарте POSIX.

\input{C/printf}

\section{atexit()}

При помощи atexit() можно добавить ф-цию, автоматически вызываемую перед выходом из вашей программы.
Кстати, программы на Си++ именно при помощи atexit() добавляют деструкторы глобальных объектов.

Можно попробовать:

\begin{lstlisting}
#include <string>

std::string s="test";

int main()
{
};
\end{lstlisting}

В листинге на ассемблере найдем конструктор этого глобального объекта:

\begin{lstlisting}[caption=MSVC 2010]
??__Es@@YAXXZ PROC					; `dynamic initializer for 's'', COMDAT
; Line 3
	push	ebp
	mov	ebp, esp
	push	OFFSET $SG22192
	mov	ecx, OFFSET ?s@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; s
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??__Fs@@YAXXZ			; `dynamic atexit destructor for 's''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Es@@YAXXZ ENDP					; `dynamic initializer for 's''

??__Fs@@YAXXZ PROC					; `dynamic atexit destructor for 's'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?s@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; s
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	ebp
	ret	0
??__Fs@@YAXXZ ENDP					; `dynamic atexit destructor for 's''
\end{lstlisting}

Конструктор, конструируя, также регистрирует деструктор объекта в atexit().

\input{C/bsearch.tex}

\section{setjmp(), longjmp()}

В каком-то смысле, это реализация исключений в Си.

jmp\_buf это просто структура содержащая в себе набор регистров, но самые важные, это адрес текущей инструкции
и адрес указателя стека.
Всё что делает setjmp() это просто записывает текущие регистры процессора в эту структуру.
А всё что делает longjmp() это восстанавливает состояние регистров.

Это часто используется для возврата из каких-то глубоких мест наружу, обычно, в случае ошибок.
Собственно, как и исключения в Си++.

Например, в Oracle RDBMS, когда происходит некая ошибка, и пользователь код ошибки, сообщение об ошибке, итд,
в реальности, там срабатывает longjmp откуда-то из глубины. Для того же это используется и в bash.

Этот механизм даже немного гибче чем исключения в других ЯП --- нет никаких проблем ``устанавливать точки 
возврата'' в каких угодно местах программы и затем возвращаться туда по мере необходимости.

\label{goto}
Пофантазируя, можно даже сказать что longjmp это такой супермега-goto, обходящий блоки, ф-ции, и восстанавливающий
состояние стека.

Однако, нельзя забывать, что всё что восстанавливает longjmp это регистры. Выделенная память остается выделенной,
никаких деструкторов, как в Си++, вызвано не будет. Никакого \ac{RAII} здесь нет. 
С другой стороны, так как часть стека просто аннулируется, 
память выделенная при помощи alloca()\ref{alloca} будет также аннулирована.

