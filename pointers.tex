\section{\IFRU{Указатели}{Pointers}}

Как однажды сказал Дональд Кнут в интервью\cite{KnuthInterview1993}, то как в Си устроены указатели, это является
очень удачной инновацией в языках программирования по тем временам.

Итак, определимся с терминологией. Указатель это просто адрес какого-то элемента в памяти. Указатели настолько
популярны, потому что в какую-то функцию намного проще передать просто адрес объекта в памяти, вместо того
чтобы передавать весь объект --- ведь это абсурдно. К тому же, вызываемая функция, например, обрабатывающая
ваш массив данных, просто изменит что-то в нем, вместо того чтобы возвращать новый, измененный массив данных, 
что тоже абсурдно.

Возьмем простой пример. Стандартная функция \IT{strtok()} делит строку на подстроки, используя заданный символ
как разделитель. К примеру, мы можем подать на вход строку \TT{The quick brown fox jumps over the lazy dog} 
и задать пробел в качестве разделителя.

\lstinputlisting{src/strtok_ex1.c}

Мы в итоге получим на выходе:

\begin{lstlisting}
The
quick
brown
fox
jumps
over
the
lazy
dog
\end{lstlisting}

Что тут в реальности происходит, это то что ф-ция \IT{strtok()} просто находит в заданной строке следующий пробел 
(либо иной заданный разделитель),
записывает туда $0$ (что по соглашениям текстовых строк в Си является концом строки) и возвращает указатель на это
место.

В качестве недостатка \IT{strtok()} можно отметить, что эта ф-ция ``портит'' входную строку, записывая нули
на месте разделителей.

Но вот что важно заметить: никакие строки или подстроки не копируются в памяти. Входная
строка остается там же где и лежала. В \IT{strtok()} передается только указатель на нее, или, её адрес.
Эта ф-ция затем, после
того как записывает $0$, возвращает \IT{адрес} каждого следующего ``слова''.
Адрес затем подается на вход в \IT{printf()}, где происходит его вывод на консоль.

Обратите также внимание на то что в исходнике присутствует и некорректное объявление \IT{str}. Оно тем некорректное
что в Си строка имеет тип \IT{const char*}, то есть, распологается в константном сегменте данных, защищенным
от записи.
Если так сделать, то \IT{strtok()} не сможет модифицировать строку записывая туда нули и процесс ``упадет''.

Так что, в нашем примере, строка выделяется как массив \IT{char} а не массив \IT{const char}.

Обобщая, скажем что работа со строками в Си происходит только лишь используя адреса этих строк. К примеру,
ф-ция сравнения строк \IT{strcmp()} на вход берет два адреса двух строк и по одному символу сравнивает их.
Было бы очень абсурдно копировать куда-то эти две строки лишний раз, чтобы \IT{strcmp()} обработала их.

Трудность понимания указателей в Си связана с тем, что указатель это ``часть'' объекта. Указатель на строку,
это не сама строка. Сама строка еще должна где-то в памяти хранится, под нее нужно выделять место, итд.

В ЯП более высокого уровня, объект и указатель на него могут быть представлены как единое целое, что облегчает
понимание.
Впрочем, это не значит что в этих ЯП строки и иные объекты неразумно копируются много раз при передаче 
в другие функции,
там точно так же используются указатели, но просто эта механика скрыта от программиста.

\subsection{Синтаксический сахар для a[i]}

Ради упрощения, можно сказать что в Си нет массивов вообще, а есть только синтаксический сахар для выражений
вроде \IT{a[i]}.

К примеру, возможно вы видели такой трюк:

\begin{lstlisting}
printf ("%c", 3["hello"]);
\end{lstlisting}

Это выдаст 'l'. 
Это происходит, потому что любое выражение \IT{a[i]}, на самом деле преобразовывается в \IT{*(a+i)}
\cite[6.5.2.1]{C99TC3}.
\IT{3["hello"]} преобразовывается в \IT{*(3+"hello")}, а \IT{"hello"} это просто указатель на массив символов, 
типа \IT{const char*}.
\IT{3+"hello"} это в итоге указатель на часть строки, то есть, \IT{"lo"}. А \IT{*("lo")} это cимвол 'l'. 
Вот почему это работает.

Но так врядли стоит писать, если вы конечно не готовите программу на конкурс 
The International Obfuscated C Code Contest\footnote{\url{http://www.ioccc.org/}}.
Так что я привел этот пример, чтобы наглядно показать, 
что выражения вроде \IT{a[i]} это синтаксический сахар.

При некотором упорстве, в Си вообще можно обойтись без индексации массивов, хотя выглядеть это будет не очень
эстетично.

Кстати, так легко понять как работают отрицательные индексы массивов. \IT{a[-3]} просто преобразуется в \IT{*(a-3)},
так адресуется элемент лежащий перед самим массивом.
И хотя это вполне возможно, так можно делать только если вы точно знаете, что вы делаете.

В Си массив это, в каком-то смысле, это просто место в памяти под массив плюс указатель, указывающий
на него. 

Вот почему имя массива в Си можно считать за указатель:

Если вы объявите глобальную переменную \IT{int a[10]}, то \IT{a} будет иметь тип \IT{int*}.
Позже, когда где-то в коде
вы укажете \IT{x=a[5]}, выражение будет преобразовано в \IT{x=*(a+5)}. От начала массива (то есть, первого элемента
массива), будет отсчитано 5 элементов, затем оттуда прочитается элемент для записи в \IT{x}.

\subsection{\IFRU{Арифметика указателей}{Pointer arithmetic}}

Простой пример:

\lstinputlisting{src/phonebook1.c}

Мы объяляем глобальный массив из структур. Если скомпилировать это в GCC с ключом \IT{-S} либо в MSVC с ключом
\IT{/Fa}, мы увидим листинг на ассемблере и то, как компилятор расположил эти строки. 

Расположил он их как линейный массив указателей на строки, вот так:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  ячейка 0    & адрес строки ``Kirk'' \\
  ячейка 1    & адрес строки ``Hammett'' \\
  ячейка 2    & адрес строки ``555-1234'' \\
  ячейка 3    & адрес строки ``Lars'' \\
  ячейка 4    & адрес строки ``Ulrich'' \\
  ячейка 5    & адрес строки ``555-5678'' \\
  ячейка 6    & адрес строки ``James'' \\
  ячейка 7    & адрес строки ``Hetfield'' \\
  ячейка 8    & адрес строки ``555-1122'' \\
  ячейка 9    & адрес строки ``Robert'' \\
  ячейка 10   & адрес строки ``Trujillo'' \\
  ячейка 11   & адрес строки ``555-7788'' \\
  ячейка 12   & 0 \\
  ячейка 13   & 0 \\
  ячейка 14   & 0 \\
\hline
\end{tabular}
\end{center}

Ф-ции \IT{dump1()} и \IT{dump2()} эквивалентны.

Но в первой итератор \IT{i} начинается с 0 и к нему прибавляется 1 на каждой итерации.

Во второй ф-ции итератор \IT{i} указывает на начало массива и затем, к нему прибавляется длина структуры 
(а не 1 байт, как можно поначалу ошибочно подумать),
таким образом, на каждой итерации, \IT{i} указывает на следующий элемент массива.

